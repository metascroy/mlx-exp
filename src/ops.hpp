// AUTO-GENERATED FILE â€” do not edit by hand
// Generated by generate_from_schema.py based on ops_schema.py
#pragma once
#include <cstdint>
#include <cstddef>
#include <optional>
#include <variant>
#include <vector>
#include <string>
#include <utility>

struct Tid { uint32_t idx{}; };
template <typename T>
struct Vid { uint32_t idx{}; };

enum class DTypeId : int {
  f16,
  f32,
  bf16,
  i32,
  i64,
  u32,
  u8,
  boolean,
};

// -----------------------------------------------------------------------------
// Per-op payloads (schemas)
// -----------------------------------------------------------------------------
struct NoopNode {
};

struct LinearNode {
  Tid x { Tid{} };
  Tid weight { Tid{} };
  Tid out { Tid{} };
  std::optional<Tid> bias { std::nullopt };
};

struct RMSNormNode {
  Tid x { Tid{} };
  Tid weight { Tid{} };
  Tid out { Tid{} };
  float eps { 1e-05f };
};

struct RopeNode {
  Tid q_in { Tid{} };
  Tid k_in { Tid{} };
  Tid q_out { Tid{} };
  Tid k_out { Tid{} };
  int head_dim {};
  Vid<int> pos { Vid<int>{} };
  std::optional<Tid> freqs { std::nullopt };
  bool traditional { false };
  std::optional<float> base { 500000.0f };
  float scale { 1.0f };
};

struct SdpaNode {
  Tid q { Tid{} };
  Tid k { Tid{} };
  Tid v { Tid{} };
  Tid out { Tid{} };
  float scale { 1.0f };
  std::optional<Tid> mask { std::nullopt };
  bool causal { false };
};

struct AddNode {
  Tid a { Tid{} };
  Tid b { Tid{} };
  Tid out { Tid{} };
};

struct MulNode {
  Tid a { Tid{} };
  Tid b { Tid{} };
  Tid out { Tid{} };
};

struct SiluNode {
  Tid x { Tid{} };
  Tid out { Tid{} };
};

struct ReshapeNode {
  Tid x { Tid{} };
  Tid out { Tid{} };
  std::vector<int> shape {};
};

struct TransposeNode {
  Tid x { Tid{} };
  Tid out { Tid{} };
  std::vector<int> perm {};
};

struct ContigNode {
  Tid x { Tid{} };
  Tid out { Tid{} };
};

struct GatherNode {
  Tid table { Tid{} };
  Tid ids { Tid{} };
  Tid out { Tid{} };
};

struct SliceNode {
  Tid x { Tid{} };
  Tid out { Tid{} };
  std::variant<int, Vid<int>> axis { std::variant<int, Vid<int>>{} };
  std::variant<int, Vid<int>> start { std::variant<int, Vid<int>>{} };
  std::variant<int, Vid<int>> length { std::variant<int, Vid<int>>{} };
};

struct CastNode {
  Tid x { Tid{} };
  Tid out { Tid{} };
  DTypeId dtype { DTypeId::f16 };
};

struct QuantizedLinearNode {
  Tid x { Tid{} };
  Tid w { Tid{} };
  Tid scales { Tid{} };
  Tid out { Tid{} };
  std::optional<Tid> biases { std::nullopt };
  std::optional<Tid> bias { std::nullopt };
  int group_size { 64 };
  int bits { 4 };
  std::string mode { "affine" };
  DTypeId out_dtype { DTypeId::f32 };
};

struct ConcatNode {
  Tid a { Tid{} };
  Tid b { Tid{} };
  Tid out { Tid{} };
  int axis { 0 };
};

struct FullNode {
  Tid out { Tid{} };
  std::vector<int> shape {};
  float v { 0.0f };
  DTypeId dtype { DTypeId::f16 };
};

struct ZerosNode {
  Tid out { Tid{} };
  std::vector<int> shape {};
  DTypeId dtype { DTypeId::f16 };
};

struct OnesNode {
  Tid out { Tid{} };
  std::vector<int> shape {};
  DTypeId dtype { DTypeId::f16 };
};

struct ArgmaxNode {
  Tid x { Tid{} };
  Tid out { Tid{} };
  int axis { -1 };
};

struct SliceUpdateNode {
  Tid dst { Tid{} };
  Tid update { Tid{} };
  std::variant<int, Vid<int>> axis { std::variant<int, Vid<int>>{} };
  std::variant<int, Vid<int>> start { std::variant<int, Vid<int>>{} };
  std::variant<int, Vid<int>> length { std::variant<int, Vid<int>>{} };
};

struct QuantizedGatherNode {
  Tid table_q { Tid{} };
  Tid scales { Tid{} };
  Tid ids { Tid{} };
  Tid out { Tid{} };
  std::optional<Tid> biases { std::nullopt };
  int group_size { 64 };
  int bits { 4 };
  std::string mode { "affine" };
  DTypeId out_dtype { DTypeId::f32 };
};

// -----------------------------------------------------------------------------
// X-macro master list (NAME, PAYLOAD_TYPE)
// -----------------------------------------------------------------------------
#ifndef OP_LIST
#define OP_LIST(X) \
  X(NOOP, NoopNode) \
  X(LINEAR, LinearNode) \
  X(RMS_NORM, RMSNormNode) \
  X(ROPE_APPLY, RopeNode) \
  X(SDPA, SdpaNode) \
  X(ADD, AddNode) \
  X(MUL, MulNode) \
  X(SILU, SiluNode) \
  X(RESHAPE, ReshapeNode) \
  X(TRANSPOSE, TransposeNode) \
  X(CONTIGUOUS, ContigNode) \
  X(GATHER, GatherNode) \
  X(SLICE, SliceNode) \
  X(CAST, CastNode) \
  X(QUANTIZED_LINEAR, QuantizedLinearNode) \
  X(CONCAT, ConcatNode) \
  X(FULL, FullNode) \
  X(ZEROS, ZerosNode) \
  X(ONES, OnesNode) \
  X(ARGMAX, ArgmaxNode) \
  X(SLICE_UPDATE, SliceUpdateNode) \
  X(QUANTIZED_GATHER, QuantizedGatherNode)
#endif

enum class OpCode : uint8_t {
#define DEFINE_ENUM(NAME, PAYLOAD) NAME,
  OP_LIST(DEFINE_ENUM)
#undef DEFINE_ENUM
  SENTINEL
};

template <OpCode> struct OpPayload;
#define DEFINE_TRAIT(NAME, PAYLOAD) \
  template <> struct OpPayload<OpCode::NAME> { using type = PAYLOAD; };
OP_LIST(DEFINE_TRAIT)
#undef DEFINE_TRAIT

template <OpCode OC>
using OpPayloadT = typename OpPayload<OC>::type;

// NodeVariant (allows duplicate payload types via index-based emplace)
using NodeVariant = std::variant<
  NoopNode,
  LinearNode,
  RMSNormNode,
  RopeNode,
  SdpaNode,
  AddNode,
  MulNode,
  SiluNode,
  ReshapeNode,
  TransposeNode,
  ContigNode,
  GatherNode,
  SliceNode,
  CastNode,
  QuantizedLinearNode,
  ConcatNode,
  FullNode,
  ZerosNode,
  OnesNode,
  ArgmaxNode,
  SliceUpdateNode,
  QuantizedGatherNode,
  std::monostate
>;

enum : size_t {
  VAR_IDX_NOOP,
  VAR_IDX_LINEAR,
  VAR_IDX_RMS_NORM,
  VAR_IDX_ROPE_APPLY,
  VAR_IDX_SDPA,
  VAR_IDX_ADD,
  VAR_IDX_MUL,
  VAR_IDX_SILU,
  VAR_IDX_RESHAPE,
  VAR_IDX_TRANSPOSE,
  VAR_IDX_CONTIGUOUS,
  VAR_IDX_GATHER,
  VAR_IDX_SLICE,
  VAR_IDX_CAST,
  VAR_IDX_QUANTIZED_LINEAR,
  VAR_IDX_CONCAT,
  VAR_IDX_FULL,
  VAR_IDX_ZEROS,
  VAR_IDX_ONES,
  VAR_IDX_ARGMAX,
  VAR_IDX_SLICE_UPDATE,
  VAR_IDX_QUANTIZED_GATHER,
  VAR_IDX_SENTINEL
};

template <OpCode> struct OpVariantIndex;
template <> struct OpVariantIndex<OpCode::NOOP> { static constexpr size_t value = VAR_IDX_NOOP; };
template <> struct OpVariantIndex<OpCode::LINEAR> { static constexpr size_t value = VAR_IDX_LINEAR; };
template <> struct OpVariantIndex<OpCode::RMS_NORM> { static constexpr size_t value = VAR_IDX_RMS_NORM; };
template <> struct OpVariantIndex<OpCode::ROPE_APPLY> { static constexpr size_t value = VAR_IDX_ROPE_APPLY; };
template <> struct OpVariantIndex<OpCode::SDPA> { static constexpr size_t value = VAR_IDX_SDPA; };
template <> struct OpVariantIndex<OpCode::ADD> { static constexpr size_t value = VAR_IDX_ADD; };
template <> struct OpVariantIndex<OpCode::MUL> { static constexpr size_t value = VAR_IDX_MUL; };
template <> struct OpVariantIndex<OpCode::SILU> { static constexpr size_t value = VAR_IDX_SILU; };
template <> struct OpVariantIndex<OpCode::RESHAPE> { static constexpr size_t value = VAR_IDX_RESHAPE; };
template <> struct OpVariantIndex<OpCode::TRANSPOSE> { static constexpr size_t value = VAR_IDX_TRANSPOSE; };
template <> struct OpVariantIndex<OpCode::CONTIGUOUS> { static constexpr size_t value = VAR_IDX_CONTIGUOUS; };
template <> struct OpVariantIndex<OpCode::GATHER> { static constexpr size_t value = VAR_IDX_GATHER; };
template <> struct OpVariantIndex<OpCode::SLICE> { static constexpr size_t value = VAR_IDX_SLICE; };
template <> struct OpVariantIndex<OpCode::CAST> { static constexpr size_t value = VAR_IDX_CAST; };
template <> struct OpVariantIndex<OpCode::QUANTIZED_LINEAR> { static constexpr size_t value = VAR_IDX_QUANTIZED_LINEAR; };
template <> struct OpVariantIndex<OpCode::CONCAT> { static constexpr size_t value = VAR_IDX_CONCAT; };
template <> struct OpVariantIndex<OpCode::FULL> { static constexpr size_t value = VAR_IDX_FULL; };
template <> struct OpVariantIndex<OpCode::ZEROS> { static constexpr size_t value = VAR_IDX_ZEROS; };
template <> struct OpVariantIndex<OpCode::ONES> { static constexpr size_t value = VAR_IDX_ONES; };
template <> struct OpVariantIndex<OpCode::ARGMAX> { static constexpr size_t value = VAR_IDX_ARGMAX; };
template <> struct OpVariantIndex<OpCode::SLICE_UPDATE> { static constexpr size_t value = VAR_IDX_SLICE_UPDATE; };
template <> struct OpVariantIndex<OpCode::QUANTIZED_GATHER> { static constexpr size_t value = VAR_IDX_QUANTIZED_GATHER; };

static_assert(std::variant_size<NodeVariant>::value >= VAR_IDX_SENTINEL,
              "NodeVariant must have at least as many alts as ops");

static constexpr const char* kOpName[static_cast<size_t>(OpCode::SENTINEL)] = {
#define NAME_ROW(NAME, PAYLOAD) #NAME,
  OP_LIST(NAME_ROW)
#undef NAME_ROW
};
static_assert(sizeof(kOpName) / sizeof(kOpName[0]) ==
              static_cast<size_t>(OpCode::SENTINEL),
              "kOpName size must match OpCode::SENTINEL");

// Instruction type w/ index-based emplace for duplicate payloads
struct Instr {
  OpCode      op{OpCode::NOOP};
  NodeVariant node{
    NoopNode{}
  };

  Instr() = default;

  template <OpCode OC>
  static Instr make(OpPayloadT<OC> payload) {
    Instr i;
    i.op = OC;
    i.node.template emplace<OpVariantIndex<OC>::value>(std::move(payload));
    return i;
  }

  template <class T>       T& get()       { return std::get<T>(node); }
  template <class T> const T& get() const { return std::get<T>(node); }

  template <class F> decltype(auto) visit(F&& f)       { return std::visit(std::forward<F>(f), node); }
  template <class F> decltype(auto) visit(F&& f) const { return std::visit(std::forward<F>(f), node); }
};

static_assert(static_cast<size_t>(OpCode::SENTINEL) == ([]{
  size_t n = 0;
#define COUNT_ONE(NAME, PAYLOAD) ++n;
  OP_LIST(COUNT_ONE)
#undef COUNT_ONE
  return n;
})(), "OpCode::COUNT mismatch with OP_LIST");

// Auto-generated factories: make_<OP>(payload)
#define DEFINE_MAKE_FN(NAME, PAYLOAD) \
  inline Instr make_##NAME(PAYLOAD n) { return Instr::make<OpCode::NAME>(std::move(n)); }
OP_LIST(DEFINE_MAKE_FN)
#undef DEFINE_MAKE_FN
