# AUTO-GENERATED FILE â€” do not edit by hand
# Generated by generate_from_schema.py based on ops_schema.py
from __future__ import annotations
from typing import Optional, List, Any, Dict
from ops_schema import DTypeId

class OpsMixin:
    """
    Generated mixin with one method per op.
    Subclasses must implement:
      - _coerce_payload(self, op: str, payload: Dict[str, Any]) -> Dict[str, Any]
      - _emit(self, op: str, **payload) -> None
    """

    def NOOP(self) -> None:
        self._emit("NOOP")

    def LINEAR(self, *, x: Any, weight: Any, out: Any, bias: Optional[Any]) -> None:
        payload = self._coerce_payload("LINEAR", locals())
        self._emit("LINEAR", **payload)

    def RMS_NORM(self, *, x: Any, weight: Any, out: Any, eps: float) -> None:
        payload = self._coerce_payload("RMS_NORM", locals())
        self._emit("RMS_NORM", **payload)

    def LAYER_NORM(self, *, x: Any, out: Any, weight: Optional[Any], bias: Optional[Any], eps: float) -> None:
        payload = self._coerce_payload("LAYER_NORM", locals())
        self._emit("LAYER_NORM", **payload)

    def ROPE_APPLY(self, *, q_in: Any, k_in: Any, q_out: Any, k_out: Any, head_dim: int, pos: Any, freqs: Optional[Any], traditional: bool, base: Optional[float], scale: float) -> None:
        payload = self._coerce_payload("ROPE_APPLY", locals())
        self._emit("ROPE_APPLY", **payload)

    def SDPA(self, *, q: Any, k: Any, v: Any, out: Any, scale: float, mask: Optional[Any], causal: bool) -> None:
        payload = self._coerce_payload("SDPA", locals())
        self._emit("SDPA", **payload)

    def ADD(self, *, a: Any, b: Any, out: Any) -> None:
        payload = self._coerce_payload("ADD", locals())
        self._emit("ADD", **payload)

    def ADD_SCALAR(self, *, a: int | Any, b: int | Any, out: Any) -> None:
        payload = self._coerce_payload("ADD_SCALAR", locals())
        self._emit("ADD_SCALAR", **payload)

    def SYM_SIZE(self, *, a: Any, dim: int, out: Any) -> None:
        payload = self._coerce_payload("SYM_SIZE", locals())
        self._emit("SYM_SIZE", **payload)

    def MUL(self, *, a: Any, b: Any, out: Any) -> None:
        payload = self._coerce_payload("MUL", locals())
        self._emit("MUL", **payload)

    def CONV_1D(self, *, x: Any, w: Any, out: Any, stride: int, padding: int, dilation: int, groups: int) -> None:
        payload = self._coerce_payload("CONV_1D", locals())
        self._emit("CONV_1D", **payload)

    def GELU(self, *, x: Any, out: Any) -> None:
        payload = self._coerce_payload("GELU", locals())
        self._emit("GELU", **payload)

    def ARANGE(self, *, out: Any, start: int, stop: int, step: int, dtype: Optional[DTypeId | str]) -> None:
        payload = self._coerce_payload("ARANGE", locals())
        self._emit("ARANGE", **payload)

    def SILU(self, *, x: Any, out: Any) -> None:
        payload = self._coerce_payload("SILU", locals())
        self._emit("SILU", **payload)

    def RESHAPE(self, *, x: Any, out: Any, shape: Any) -> None:
        payload = self._coerce_payload("RESHAPE", locals())
        self._emit("RESHAPE", **payload)

    def TRANSPOSE(self, *, x: Any, out: Any, perm: List[int]) -> None:
        payload = self._coerce_payload("TRANSPOSE", locals())
        self._emit("TRANSPOSE", **payload)

    def CONTIGUOUS(self, *, x: Any, out: Any) -> None:
        payload = self._coerce_payload("CONTIGUOUS", locals())
        self._emit("CONTIGUOUS", **payload)

    def ID_COPY(self, *, x: Any, out: Any) -> None:
        payload = self._coerce_payload("ID_COPY", locals())
        self._emit("ID_COPY", **payload)

    def GATHER(self, *, table: Any, ids: Any, out: Any) -> None:
        payload = self._coerce_payload("GATHER", locals())
        self._emit("GATHER", **payload)

    def SLICE(self, *, x: Any, out: Any, axis: int | Any, start: int | Any, end: int | Any) -> None:
        payload = self._coerce_payload("SLICE", locals())
        self._emit("SLICE", **payload)

    def CAST(self, *, x: Any, out: Any, dtype: DTypeId | str) -> None:
        payload = self._coerce_payload("CAST", locals())
        self._emit("CAST", **payload)

    def QUANTIZED_LINEAR(self, *, x: Any, w: Any, scales: Any, out: Any, biases: Optional[Any], bias: Optional[Any], group_size: int, bits: int, mode: str, out_dtype: DTypeId | str) -> None:
        payload = self._coerce_payload("QUANTIZED_LINEAR", locals())
        self._emit("QUANTIZED_LINEAR", **payload)

    def CONCAT(self, *, a: Any, b: Any, out: Any, axis: int) -> None:
        payload = self._coerce_payload("CONCAT", locals())
        self._emit("CONCAT", **payload)

    def FULL(self, *, out: Any, shape: List[int], v: float, dtype: DTypeId | str) -> None:
        payload = self._coerce_payload("FULL", locals())
        self._emit("FULL", **payload)

    def ZEROS(self, *, out: Any, shape: List[int], dtype: DTypeId | str) -> None:
        payload = self._coerce_payload("ZEROS", locals())
        self._emit("ZEROS", **payload)

    def ONES(self, *, out: Any, shape: List[int], dtype: DTypeId | str) -> None:
        payload = self._coerce_payload("ONES", locals())
        self._emit("ONES", **payload)

    def ARGMAX(self, *, x: Any, out: Any, axis: int) -> None:
        payload = self._coerce_payload("ARGMAX", locals())
        self._emit("ARGMAX", **payload)

    def SLICE_UPDATE(self, *, dst: Any, update: Any, axis: int | Any, start: int | Any, stop: int | Any) -> None:
        payload = self._coerce_payload("SLICE_UPDATE", locals())
        self._emit("SLICE_UPDATE", **payload)

    def QUANTIZED_GATHER(self, *, table_q: Any, scales: Any, ids: Any, out: Any, biases: Optional[Any], group_size: int, bits: int, mode: str, out_dtype: DTypeId | str) -> None:
        payload = self._coerce_payload("QUANTIZED_GATHER", locals())
        self._emit("QUANTIZED_GATHER", **payload)
